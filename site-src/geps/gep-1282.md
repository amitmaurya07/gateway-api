# GEP-696: GEP template

* Issue: [#1282](https://github.com/kubernetes-sigs/gateway-api/issues/1282)
* Status: Provisional

(See definitions in [Kubernetes KEP][kep-status].

[kep-status]: https://github.com/kubernetes/enhancements/blob/master/keps/NNNN-kep-template/kep.yaml#L9

## TLDR

End-user feedback of Gateway API has presented a trend: some users are interested in defining functionality that describes capabilities of the service more than the route you take to get to the service. In order to support these more advanced route functions, implementations need programmatic access to deeper insights about a Service’s (that is: a Kubernetes Service that would be used in an *Route backendRef) capabilities, such as TLS or websocket details. The purpose of this GEP is to add APIs for capturing those Service capabilities to enable more complex routing composition.

## Goals

* Provide a method to store properties and capabilities for service backends as extended-only features
* The method must be structured (that is, stored in a typed schema), and extensible (the design must include ways in which we can add more properties and capabilities in the future without redesigning it).
* The method should have a roadmap where we can take what we learn from this design and bring it to the core Kubernetes resources later.
* Clear separation of concerns with PolicyAttachment for properties which require multiple levels of defaults/overrides (timeouts, retries, etc).


## Non-Goals

* We don’t want to require changes to v1.Service to start with, as the turnaround time for those changes can be years.
* Our solution should not use unstructured data like labels and annotations - these are very sticky and hard to get rid of once you start using them.
* v1.Service’s appProtocol field is not fit for purpose, because it is defined as accepting values either from the [IANA Service Name registry](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtmly), or domain-prefixed values and we need more flexibility than that.
* To be populated as we discuss more.


## Introduction

As implementations have started to build out HTTPRoute support, requests for some common capabilities have started coming up, particularly TLS re-encryption (encryption between Gateway and backend), Websockets tracking, and HTTP/2 support.

Evan Anderson opened a [discussion that generated a lot of interest](https://github.com/kubernetes-sigs/gateway-api/discussions/1244), and during that discussion, we brought up a few more points:
* Whatever we do to solve this in the HTTPRoute case has applicability to describing more general service properties, like identity, which could be useful for other Route use cases.
* This may be very useful for mesh/GAMMA use cases as well as more generally for adding arbitrary future capabilities to the backend service. An example is a CA cert for connecting to the backend - that’s tightly bound to the service, but there’s nowhere to put it at the moment.

This initial form of this GEP is for the Gateway API community to agree on what problem we’re solving and why.

### What we're building

We’re looking to add specific, structured extension points somewhere in the resources used by the Gateway API to describe properties and capabilities of backend services.

The initial list includes, but is not limited to:
* TLS information for connection from the Gateway to the backend service. Note that this doesn’t include any information used for service mesh encryption, just what a Gateway’s proxy would need to be able to connect to the backend service.
* Websocket protocol information for the backend service.
* Protocol disambiguation for “upgradeable” protocols like HTTP/2 and HTTP/1.1 which operate on the same port. (Websockets may be another case of this.)

### Why build something?

The existing resources we have (Service and HTTPRoute) don’t have space for this information currently, and we have feedback from users via various implementations that it’s necessary - you could argue that some of this is table stakes for a layer 7 ingress controller.

In previous discussions, we discussed a variety of ways to achieve this goal, but there’s been a lot of discussion already, so we’re moving to a GEP discussion format to try to capture feedback more efficiently.


## API

To be written later, once we have agreement on the “what” and the “why”. (This is the “how”).


## Alternatives

Again, we need to wait until we’re writing the “how”.

## Prior Art

A number of implementations have prior art in this area.

Candace Holman has documented the TLS-specific prior art in [#1285](https://github.com/kubernetes-sigs/gateway-api/discussions/1285), and there are more details there, but to summarize those and others here:

* Istio uses a [DestinationRule resource with ClientTLSSettings](https://istio.io/latest/docs/reference/config/networking/destination-rule/#ClientTLSSettings) to capture TLS details, and the DestinationRule resource also holds traffic policy information like load balancing algorithm, connection pool size, and so on.
* Openshift’s Route resource allows the [configuration of reencryption](https://docs.openshift.com/container-platform/4.10/networking/routes/secured-routes.html#nw-ingress-creating-a-reencrypt-route-with-a-custom-certificate_secured-routes) specifically, along with custom certificate details.
* Contour’s HTTPProxy captures TLS details using an Envoy client certificate, destination CA certificate, and optional SubjectName which sets what Envoy should expect to see from the backend service, all inside the HTTPProxy resource. It also requires either a Protocol field inside the HTTProxy, or an annotation on the Service that tells Contour that the service expects TLS. This is [all documented](https://projectcontour.io/docs/v1.21.1/config/upstream-tls/), but I should note that Contour’s docs use the Envoy convention where a backend in Gateway parlance is called an Upstream (which may be confusing if you’re not used to it).
* Linkerd uses a [Server resource](https://linkerd.io/2.11/reference/authorization-policy/#server) (which is functionally pretty similar to Service in that it associates a name with a Pod selector, but also has other details like if the service supports Proxy protocol), along with a ServerAuthorization resource that specifies some constructs that sit more at the service mesh level, including identity and access control.

## References

(Add any additional document links. Again, we should try to avoid
too much content not in version control to avoid broken links)
